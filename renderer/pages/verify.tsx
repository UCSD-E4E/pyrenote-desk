import React, { useState, useRef, useEffect, MouseEvent, useCallback, useImperativeHandle, forwardRef } from 'react'
import { createPortal } from 'react-dom'
import Head from 'next/head'
import Image from 'next/image'
import styles from './verify.module.css'
import WaveSurfer from 'wavesurfer.js';
import SpectrogramPlugin from 'wavesurfer.js/dist/plugins/spectrogram';

import { ipcMain } from 'electron'
import { writeFileSync } from 'fs'
import { ALL } from 'dns'

// GENERATED BY CHAT GPT
function VIRIDIS_COLORMAP() {
    const viridisColors = [
        [68, 1, 84], [72, 35, 116], [64, 67, 135], [52, 94, 141],
        [41, 120, 142], [32, 144, 140], [34, 167, 132], [58, 190, 117],
        [96, 208, 93], [140, 219, 69], [186, 226, 54], [233, 229, 42], [253, 231, 37]
    ];
    const colorMap = [];
    for (let i = 0; i < 256; i++) {
        const t = i / 255;
        const idx = Math.floor(t * (viridisColors.length - 1));
        const nextIdx = Math.min(idx + 1, viridisColors.length - 1);
        const mix = (t * (viridisColors.length - 1)) % 1;
        const r = Math.floor((1 - mix) * viridisColors[idx][0] + mix * viridisColors[nextIdx][0]);
        const g = Math.floor((1 - mix) * viridisColors[idx][1] + mix * viridisColors[nextIdx][1]);
        const b = Math.floor((1 - mix) * viridisColors[idx][2] + mix * viridisColors[nextIdx][2]);
		colorMap.push([r/256, g/256, b/256, 1]);
    }
    return colorMap;
}

const DEFAULT_SKIPINTERVAL = 2;
const DEFAULT_PLAYSPEED = 1;


interface SpectroRef {
	id: number,
	wavesurferRef: React.RefObject<WaveSurfer>;
	isRed: boolean;
	isSelected: boolean;
	isLoaded: boolean;
	filePath: URL;
	toggleRed: () => void;
	toggleSelected: (selected) => void;
	playPause: () => boolean;
	setPlaybackRate: (number) => void;
	play: () => void;
	pause: () => void;
	setTime: (number) => void;
	getTime: () => number;
	skip: (number) => void;
}
interface SpectroProps {
	id : number,
	filePath : URL,
	onMouseEnter : ()=>void, 
	onMouseLeave : ()=>void,
	linkedSpectro : SpectroRef,
}

export default function VerifyPage() {	

	// SPECTROGRAM

	const spectrograms = useRef([]);
	const playingSpectro = useRef(null);
	const [frozen, setFrozen] = useState(false);
	const [mouseControl, setMouseControl] = useState(true);

	const [skipInterval, setSkipInterval] = useState(DEFAULT_SKIPINTERVAL);
	const [playSpeed, setPlaySpeed] = useState(DEFAULT_PLAYSPEED);
	
	const [selected, setSelected] = useState(null);
	const updateSelected = useCallback((i) => { // wraps setSelectedSpectrogram
		console.log(selected, i, frozen, mouseControl);
		if (!(frozen && mouseControl)) {
			if (selected != null) {
				spectrograms.current[selected].toggleSelected(false);
			}
			setSelected(i);
			
			//console.log(playSpeed, selectedSpectro);
			if (i != null && i >= 0) {
				spectrograms.current[i].toggleSelected(true);

				if (frozen) {
					console.log("reload");
					toggleModal();
					toggleModal();
				}
			}
			
			return i;
		}
	}, [frozen, playSpeed, selected]);


	const Spectrogram = useCallback(forwardRef<SpectroRef, SpectroProps>(({ 
		id, // -1 if modal 
		filePath, 
		onMouseEnter, 
		onMouseLeave,
		linkedSpectro=null,
	}, ref) => {
		const wavesurferRef = useRef(null);
		const containerRef = useRef(null);
		const innerRef = useRef(null);
		const [isRed, setIsRed] = useState(false);
		const [isSelected, setIsSelected] = useState(false);
		const [isLoaded, setIsLoaded] = useState(false);
	
		const setPlaybackRate = (playSpeed) => {
			console.log(playSpeed);
			wavesurferRef.current.setPlaybackRate(playSpeed);
		}
		const playPause = (playbackRate=null) => {
			if (playbackRate != null) {
				setPlaybackRate(playbackRate);
			}
			wavesurferRef.current.playPause();
			return wavesurferRef.current.isPlaying;
		}
		const rightClickPlayPause = (e: MouseEvent) => { e.preventDefault(); playPause(); }
	
		useImperativeHandle(ref, ()=>{ // exposed functions
			return { // SpectroRef
				id,
				wavesurferRef,
				isRed,
				isSelected,
				isLoaded,
				filePath,
				toggleRed: () => { setIsRed(prev => !prev); },
				toggleSelected: (S) => { setIsSelected(S); },
				setPlaybackRate,
				playPause,
				play: () => { wavesurferRef.current.play(); },
				pause: () => { wavesurferRef.current.pause(); },
				setTime: (time) => { wavesurferRef.current.setTime(time) },
				getTime: () => { return wavesurferRef.current.getCurrentTime() },
				skip: (time) => {wavesurferRef.current.skip(time) },
			}
		});
	
		useEffect(() => { // initialize
			if (!wavesurferRef.current) {;
				wavesurferRef.current = WaveSurfer.create({
					container: innerRef.current,
					height: 0,
					fillParent: true,
					progressColor: 'white',
					cursorColor: 'yellow',
					cursorWidth: 2,
					sampleRate: 16000,
				});
				wavesurferRef.current.registerPlugin(
					SpectrogramPlugin.create({
						colorMap: VIRIDIS_COLORMAP(),
						scale: "linear",
						fftSamples: (id==-1) ? 512 : 256, // 2 * height
						labels: (id==-1),
					}),
				)
	
				wavesurferRef.current.load(filePath);
				wavesurferRef.current.on('ready', function() {
					document.getElementById(`loading-spinner-${id}`).style.display = 'none';
	
					if (linkedSpectro) {
						wavesurferRef.current.setTime(linkedSpectro.getTime());
						wavesurferRef.current.on("timeupdate", (progress) => {
							linkedSpectro.setTime(progress);
						});
					}
					setIsLoaded(true);
				});
	
				setIsRed(linkedSpectro?.isRed);
			}
			
			return () => { 
				wavesurferRef.current.destroy(); 
			};
		}, []);
	
		return (
			<div 
				key={id} 
				className={`
					${(id==-1) ? styles.waveContainerModal : styles.waveContainer} 
					${isLoaded && (isRed ? styles.redOutline : styles.greenOutline)}
					${isLoaded && (isSelected ? styles.selectOutline : styles.unselectOutline)}
				`}
				ref={containerRef}
				onMouseEnter={onMouseEnter}
				onMouseLeave={onMouseLeave}
			>
				<div id={`loading-spinner-${id}`} className={styles.waveLoadingCircle}></div>
				<div 
					id={`waveform-${id}`} 
					ref={innerRef}
					style={{ width: "100%", height: "128px"}} 
					onContextMenu={rightClickPlayPause}
				></div>
			</div>	
		)
	}), []);
	
	const ModalSpectrogram = useCallback(forwardRef<SpectroRef, SpectroProps&{toggleModal:()=>void}>(({
		id, // -1 if modal 
		filePath, 
		onMouseEnter, 
		onMouseLeave,
		linkedSpectro=spectrograms.current[selected],
		toggleModal,
	}, ref) => {
		console.log("portal reloaded");
		const modalRef = useRef(null);
		return (
			<div ref={modalRef} className={styles.modal}>
				<div>{linkedSpectro?.id}</div>
				<Spectrogram 
					id={-1} 
					filePath={filePath} 
					onMouseEnter={onMouseEnter}
					onMouseLeave={onMouseLeave}
					linkedSpectro={linkedSpectro}
					ref={ref}
				/>
				<button onClick={toggleModal}>Close</button>
			</div>
		);
	}), [selected]);


	// MODAL

	const [showModal, setShowModal] = useState(false);
	const toggleModal = useCallback(() => {  // wraps setShowModal
		if (selected != null) {
			setShowModal((prev) => {
				setFrozen(!prev);
				if (prev) { // EXIT MODAL
					playingSpectro.current = null;
					return false;
				} else { // SHOW MODAL
					setMouseControl(false);
					if (playingSpectro.current != null) {
						spectrograms.current[playingSpectro.current].pause();
					}
					return true;
				}
			});
		}		
	}, [selected, frozen]);

	useEffect(() => {
		if (showModal) {
			document.getElementById("container").classList.add(styles.noInteraction);
		} else {
			document.getElementById("container").classList.remove(styles.noInteraction);
		}
	}, [showModal]);


	// PAGE SETUP

	const [ROWS, setROWS] = useState(5); // try not to change this (spectrogram height is not very flexible)
	const [COLS, setCOLS] = useState(2);
	const FILES_PER_PAGE = ROWS*COLS;
	
	const [audioFiles, setAudioFiles] = useState([]);
	const [currentPage, setCurrentPage] = useState(1);
	const [forceReloadKey, setForceReloadKey] = useState(0); // crucial for switching pages	
	
	const ALLOWED_FILE_TYPES = [
		"audio/mp3", "audio/wav", 
		"text/plain", "application/json"
	];

	async function handleFileSelection(event) {
		async function processInput() {
			const processed = []
			const fileInput = Array.from(event.target.files) as File[];

			console.log("start");

			const filePromises = fileInput.map((file, i) => {	
				return new Promise<void>((resolve, reject) => {
					if (file.type == ALLOWED_FILE_TYPES[0] || file.type == ALLOWED_FILE_TYPES[1]) { // "audio" file
						processed.push({filePath: URL.createObjectURL(file), isInvalid: false});
						resolve();
						return;
					} else if (file.type == ALLOWED_FILE_TYPES[2] || file.type == ALLOWED_FILE_TYPES[3]) { // "save" file
						const reader = new FileReader();
							
						reader.onload = (e) => {
							try {
								const text = e.target?.result as string; 
								const jsonData = JSON.parse(text);
								console.log(jsonData);
								for (let j = 0; j < jsonData.table.length; j++) {
									processed.push({filePath: jsonData.table[j].path, isInvalid: jsonData.table[j].isInvalid || false});
								}
								resolve();
								return;
							} catch (error) {
								console.error("Error reading file", error);
								reject(new Error("Error reading file"));
							}
						}
						
						reader.readAsText(file);
					} else {
						resolve();
					}
				})
			});
			
			await Promise.all(filePromises);
			console.log("end");
			return processed;
		}
		
		const processed = await processInput();
		//console.log(processed.length);
		setAudioFiles(processed);
		setCurrentPage(1); // Reset to first page
	};

	const totalPages = Math.ceil(audioFiles.length / FILES_PER_PAGE);
	const currentFiles = audioFiles.slice((currentPage-1)*FILES_PER_PAGE, (currentPage)*FILES_PER_PAGE); 
	const numFiles = currentFiles.length;
	const numRows = Math.ceil(numFiles / COLS);
	const numSpots = numRows * COLS;


	// MENU

	const nextPage = () => {
		if (currentPage < totalPages) {
			setCurrentPage((prev) => Math.min(prev + 1, totalPages));
			setForceReloadKey((prev) => prev + 1);
		}
	}
	const prevPage = () => {
		if (currentPage > 1) {
			setCurrentPage((prev) => Math.max(prev - 1, 1));
			setForceReloadKey((prev) => prev + 1);
		}
	}
	const saveToJSON = () => {
		/*
		var obj = { table: [] };
		for (let i = 0; i < spectrograms.current.length; i++) {
			const spectro = spectrograms.current[i];
			obj.table.push({path: spectro.filePath, isInvalid: spectro.isRed});
		}
		var json = JSON.stringify(obj);
		console.log(json);
		window.ipc.send("save-file", {filename: "renderer/public/audio/verification_save_output.txt", content: json});*/
		console.log("save feature disabled for now")
	}
	useEffect(() => {
        window.ipc.on("save-file-success", (_event, msg) => console.log("success: ", msg));
        window.ipc.on("save-file-error", (_event, msg) => console.log("error: ", msg));
    }, []);


	// ACTIONS

	const moveSelectionUp = () => { setMouseControl(false); updateSelected(selected==null ? 0 : Math.max(selected - COLS, selected % COLS)); }
	const moveSelectionDown = () => { setMouseControl(false); updateSelected(selected==null ? 0 : Math.min(selected + COLS, numFiles-1, numSpots-COLS+(selected % COLS))); }
	const moveSelectionLeft = () => { setMouseControl(false); updateSelected(selected==null ? 0 : Math.max(selected - 1, 0)); }
	const moveSelectionRight = () => { setMouseControl(false); updateSelected(selected==null ? 0 : Math.min(selected + 1, numFiles-1)); }
	const toggleValidity = () => { 
		if (selected != null) {spectrograms.current[selected].toggleRed();}; 
		if (showModal) {spectrograms.current[-1].toggleRed();}
	}
	const playPauseSelection = () => { 
		if (selected == null) { return }; // null
		if (playingSpectro.current != null && playingSpectro.current != selected) { spectrograms.current[playingSpectro.current].pause(); }; // pause existing
		
		const id = showModal ? -1 : selected;

		spectrograms.current[id].setPlaybackRate(playSpeed); // set speed of selected
		const isPlaying = spectrograms.current[id].playPause(); // play/pause selected
		playingSpectro.current = (isPlaying ? selected : null);
	}
	const skipBack = () => { if (selected != null) {spectrograms.current[showModal ? -1 : selected].skip(-skipInterval);}; }
	const skipForward = () => { if (selected != null) {spectrograms.current[showModal ? -1 : selected].skip(skipInterval);}; } 
	const doubleSkipInterval = () => { setSkipInterval((prev) => prev*2) } 
	const halveSkipInterval = () => { setSkipInterval((prev) => prev/2) } 
	const doublePlaySpeed = () => { 
		setPlaySpeed((prev) => {
			let p = Math.min(2, prev*2); 
			if (playingSpectro.current != null) {spectrograms.current[playingSpectro.current].setPlaybackRate(p)}; 
			return p;
		}); 
	}
	const halvePlaySpeed = () => { 
		setPlaySpeed((prev) => {
			let p = Math.max(0.25, prev/2); 
			if (playingSpectro.current != null) {spectrograms.current[playingSpectro.current].setPlaybackRate(p)}; 
			return p;
		}); 
	}
	const resetIncrements = () => { 
		setSkipInterval(DEFAULT_SKIPINTERVAL); 
		setPlaySpeed(DEFAULT_PLAYSPEED); 
		if (playingSpectro.current != null) {spectrograms.current[playingSpectro.current].setPlaybackRate(DEFAULT_PLAYSPEED)}; 
	}

	const keybinds = {
		"w": moveSelectionUp,
		"a": moveSelectionLeft,
		"s": moveSelectionDown,
		"d": moveSelectionRight,
		"/": toggleValidity,
		" ": playPauseSelection,
		",": skipBack,
		".": skipForward,
		"l": doubleSkipInterval,
		"k": halveSkipInterval,
		"m": doublePlaySpeed,
		"n": halvePlaySpeed,
		"r": resetIncrements,
		"o": toggleModal,
		"Enter": nextPage,
		"Backspace": prevPage,
	}

	useEffect(() => { // handle keyboard input
		const handleKeyDown = (event) => {
			if (event.key == " ") {
				event.preventDefault(); 
			}
			//console.log(event.key);
			const func = keybinds[event.key];				
			if (func) {
				func();
			}
		};

		window.addEventListener("keydown", handleKeyDown);
		return () => window.removeEventListener("keydown", handleKeyDown);
	}, [selected, playingSpectro, playSpeed, skipInterval, frozen]);
	

	
	return (
		<React.Fragment>
			<Head>
				<title>Verify Page</title>
			</Head>
			<div id="container" className={styles.container} onMouseMove={() => {if (!frozen) setMouseControl(true)}}>
				<div className = {styles.verifyButtonMenu}>

					<label className={styles.pickFiles}>
						<p>Select files</p>
						<input type="file" accept=".mp4, .wav, .txt, .json" className={styles.hiddenInputFile} multiple onChange={handleFileSelection}/>
					</label>

					{audioFiles.length > 0 && (
						<>
							<div className={styles.nextFiles} onClick={nextPage}>
								<Image
								src="/images/RArrow.png"
								alt="Next files"
								width={45}
								height={45}
								/>
							</div>
							<div className={styles.prevFiles} onClick={prevPage}>
								<Image
								src="/images/LArrow.png"
								alt="Previous files"
								width={45}
								height={45}
								/>
							</div>
							<div className={styles.save} onClick={saveToJSON}>
								<Image
								src="/images/database.png"
								alt="Save to JSON"
								width={45}
								height={45}
								/>
							</div>
						</>
					)}
					
					<div>
						<p>Skip Interval: {skipInterval}</p>
						<button onClick={doubleSkipInterval}>+</button>
						<button onClick={halveSkipInterval}>-</button>
					</div>
					
					<div>
						<p>Playback Speed: {playSpeed}</p>
						<button onClick={doublePlaySpeed}>+</button>
						<button onClick={halvePlaySpeed}>-</button>
					</div>

					<div>
						<p>COLUMNS: {COLS}</p>
						<button onClick={() => setCOLS((prev) => {return prev+1})}>+</button>
						<button onClick={() => setCOLS((prev) => {return prev-1})}>-</button>
					</div>

					<div>
						<p>Selected: {selected}</p>
					</div>
				</div>

				{audioFiles.length > 0 && (
					<>
						<div id="grid" key={forceReloadKey} className={styles.grid} style={{
							gridTemplateColumns: `repeat(${COLS}, 1fr)`,
							gridTemplateRows: `repeat(${ROWS}, auto)`,
						}}>
							{currentFiles.map(({filePath, isInvalid}, i) => (
								<Spectrogram 
									key={i}
									id={i} 
									filePath={filePath} 
									onMouseEnter={() => {
										if (mouseControl) {
											updateSelected(i);
										}
									}}
									onMouseLeave={() => {
										if (mouseControl) {
											updateSelected(null);
										}
									}}
									linkedSpectro={null}
									ref={(el) => {
										if (el) spectrograms.current[i] = el; // Populate dynamically
									}}
								/>
							))}
						</div>
					</>
				)}

				{showModal && createPortal(
					<ModalSpectrogram
						key={-1}
						id={-1} 
						filePath={spectrograms.current[selected].filePath} 
						onMouseEnter={()=>{}}
						onMouseLeave={()=>{}}
						linkedSpectro={spectrograms.current[selected]}
						ref={(el) => {
							if (el) spectrograms.current[-1] = el; // Populate dynamically
						}}
						toggleModal={toggleModal}
					/>,
					document.body
				)}
			</div>
		</React.Fragment>
	)
}