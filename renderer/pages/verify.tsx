import React, { useState, useRef, useEffect, useMemo, useCallback, useImperativeHandle, forwardRef } from 'react'
import { createPortal } from 'react-dom'
import Head from 'next/head'
import Image from 'next/image'
import styles from './verify.module.css'
import WaveSurfer from 'wavesurfer.js';
import SpectrogramPlugin from 'wavesurfer.js/dist/plugins/spectrogram';

// GENERATED BY CHAT GPT
function VIRIDIS_COLORMAP() {
    const viridisColors = [
        [68, 1, 84], [72, 35, 116], [64, 67, 135], [52, 94, 141],
        [41, 120, 142], [32, 144, 140], [34, 167, 132], [58, 190, 117],
        [96, 208, 93], [140, 219, 69], [186, 226, 54], [233, 229, 42], [253, 231, 37]
    ];
    const colorMap = [];
    for (let i = 0; i < 256; i++) {
        const t = i / 255;
        const idx = Math.floor(t * (viridisColors.length - 1));
        const nextIdx = Math.min(idx + 1, viridisColors.length - 1);
        const mix = (t * (viridisColors.length - 1)) % 1;
        const r = Math.floor((1 - mix) * viridisColors[idx][0] + mix * viridisColors[nextIdx][0]);
        const g = Math.floor((1 - mix) * viridisColors[idx][1] + mix * viridisColors[nextIdx][1]);
        const b = Math.floor((1 - mix) * viridisColors[idx][2] + mix * viridisColors[nextIdx][2]);
		colorMap.push([r/256, g/256, b/256, 1]);
    }
    return colorMap;
}

function arraysEqual<T>(a: T[], b: T[]): boolean { // can be moved to a utilities file in the future
	if (a.length !== b.length) return false;
	return a.every((value, index) => value === b[index]);
}

const MAX_SKIPINTERVAL = 8;
const DEFAULT_SKIPINTERVAL = 2;
const MIN_SKIPINTERVAL = 0.5

const MAX_PLAYSPEED = 4;
const DEFAULT_PLAYSPEED = 1;
const MIN_PLAYSPEED = 0.25;

const MAX_COLUMNS = 8;
const DEFAULT_COLUMNS = 2;
const MIN_COLUMNS = 1;

enum SpectroStatus {
	Unverified,
	Valid,
	Invalid,
}

interface SpectroRef {
	id: number,
	fullIndex: number,
	wavesurferRef: React.RefObject<WaveSurfer>;
	containerRef: React.RefObject<HTMLElement>;
	status: number;
	isSelected: boolean;
	isLoaded: boolean;
	filePath: string;
	url: string;
	setStatus: (status) => void;
	setIsSelected: (selected) => void;
	setIsHovered: (hovered) => void;
	playPause: () => boolean;
	setPlaybackRate: (number) => void;
	play: () => void;
	pause: () => void;
	setTime: (number) => void;
	getTime: () => number;
	skip: (number) => void;
}
interface SpectroProps {
	id : number,
	fullIndex : number,
	url : string,
	status: number,
	onMouseEnter : ()=>void, 
	onMouseLeave : ()=>void,
	onClick : (e)=>void,
	linkedSpectro : SpectroRef,
	filePath? : string,
}
interface SaveData {
	page: number,
	columns: number,
	spectrograms: {
		filePath: string;
		status: SpectroStatus;
	}[]
}
interface ProcessedAudioFile {
	index: number;
	url: string;
	filePath: string;
	status: SpectroStatus;
}


export default function VerifyPage() {	

	// SPECTROGRAMS and PAGE SETUP

	const spectrograms = useRef([]);

	const playingSpectro = useRef(null); // spectrogram that is currently playing sound
	const [frozen, setFrozen] = useState(false);
	const [mouseControl, setMouseControl] = useState(true);

	const [skipInterval, setSkipInterval] = useState(DEFAULT_SKIPINTERVAL);
	const [playSpeed, setPlaySpeed] = useState(DEFAULT_PLAYSPEED);
	
	const [hovered, setHovered] = useState(null); // hovered spectrogram
	const updateHovered = (i) => { // wraps setHovered
		if (!frozen) {
			if (hovered != null) { spectrograms.current[hovered].setIsHovered(false); }
			setHovered(i);
			if (i != null && i >= 0) { spectrograms.current[i].setIsHovered(true); }
			
			return i;
		}
	};

	const [selected, setSelected] = useState([]); // selected spectrogram(s)
	const updateSelected = (arr) => { // wraps setSelected
		if (!(frozen && mouseControl)) {
			if (arraysEqual(arr, selected)) {
				return;
			}

			for (let i = 0; i < selected.length; i++) { // deselect current
				spectrograms.current[selected[i]].setIsSelected(false);
				spectrograms.current[selected[i]].pause();
			}
			
			setSelected(arr);

			for (let i = 0; i < arr.length; i++) {
				spectrograms.current[arr[i]].setIsSelected(true);
			}
			if (arr.length == 1 && frozen) { // reselect using arrow keys during modal
				toggleModal();
				toggleModal();
			}
			
			return arr;
		}
	};
	const firstSelected = useCallback(() => {return selected[0]}, [selected])
	const lastSelected = useCallback(() => {return selected[selected.length-1]}, [selected])

	const [ROWS, setROWS] = useState(5); // try not to change this (spectrogram height is not very flexible)
	const [COLS, setCOLS] = useState(DEFAULT_COLUMNS);
	const FILES_PER_PAGE = ROWS*COLS;
	
	// persistent storage of spectrogram data
	const [[audioFiles, setAudioFiles], updateAudioFile] = [useState<ProcessedAudioFile[]>([]), (i, status) => {
		setAudioFiles(prevItems => {
			const newItems = [...prevItems]; // make a copy
			newItems[i].status = status;      // update the element
			return newItems;                 // set new array
		});
	}]; 

	const [currentPage, setCurrentPage] = useState(1);
	const [forceReloadKey, setForceReloadKey] = useState(0); // crucial for switching pages	
	
	const totalPages = Math.ceil(audioFiles.length / FILES_PER_PAGE);
	const currentFiles = audioFiles.slice((currentPage-1)*FILES_PER_PAGE, (currentPage)*FILES_PER_PAGE); 
	const numFiles = currentFiles.length;
	const numRows = Math.ceil(numFiles / COLS);
	const numSpots = numRows * COLS;

	async function handleFileSelection() {
		let processed : ProcessedAudioFile[] = [...audioFiles];
		let spawnPage = 1;

		// NEW AUDIO FILES ARE ADDED WITHOUT CHECKING IF THEY ARE ALREADY ON SCREEN (CHANGE THIS IN THE FUTURE)
		async function handleAudioFile(file, status=SpectroStatus.Unverified) {
			if (file.extension == ".wav") { // audio file
				const blob = new Blob([file.data], {type: 'audio/wav'})
				processed.push({
					index: processed.length, 
					url: URL.createObjectURL(blob), 
					filePath: file.filePath, 
					status: status
				});

			} else if (file.extension == ".mp3") {
				const blob = new Blob([file.data], {type: 'audio/mpeg'})
				processed.push({
					index: processed.length, 
					url: URL.createObjectURL(blob), 
					filePath: file.filePath, 
					status: status
				});

			}
		}

		async function processInput(files) {
			const tasks = files.map(async (file, i) => {	
				if (file.extension == ".json") { // json file
					const jsonString = new TextDecoder("utf-8").decode(file.data);
					const jsonData : SaveData = JSON.parse(jsonString);

					for (let j = 0; j < jsonData.spectrograms.length; j++) {
						const entry = jsonData.spectrograms[j];
						const audioFile = await window.ipc.invoke('read-file-for-verification', entry.filePath);
						await handleAudioFile(audioFile, entry.status);
					}
					setCOLS(jsonData.columns);
					spawnPage = jsonData.page
				} else {
					if (file.extension == ".wav" || file.extension == ".mp3") {
						await handleAudioFile(file);
					}
				}
			})
			await Promise.all(tasks);
			return processed;
		}
		
		const files = await window.ipc.invoke('pick-files-for-verification', null);
		
		processed = await processInput(files);
		setAudioFiles(processed);
		setCurrentPage(spawnPage); // Reset to first page
	};

	const Spectrogram = useCallback(forwardRef<SpectroRef, SpectroProps>(({ 
		id, // -1 if modal 
		fullIndex,
		url: url, 
		status: _status,
		onMouseEnter, 
		onMouseLeave,
		onClick,
		linkedSpectro=null,
		filePath: filePath=null,
	}, ref) => {
		const wavesurferRef = useRef(null);
		const containerRef = useRef(null);
		const innerRef = useRef(null);
		const [status, setStatus] = useState(_status);
		const [isSelected, setIsSelected] = useState(false);
		const [isHovered, setIsHovered] = useState(false);
		const [isLoaded, setIsLoaded] = useState(false);

		let isDestroyed = false;

		const setPlaybackRate = (playSpeed) => {
			wavesurferRef.current.setPlaybackRate(playSpeed);
		}
		
		const playPause = (playbackRate=null) => {
			if (playbackRate != null) {
				setPlaybackRate(playbackRate);
			}
			wavesurferRef.current.playPause();
			return wavesurferRef.current.isPlaying();
		}

		useImperativeHandle(ref, ()=>{ // exposed functions
			return { // SpectroRef
				id,
				fullIndex,
				wavesurferRef,
				status,
				isSelected,
				isLoaded,
				filePath,
				url,
				containerRef,
				setStatus,
				setIsSelected,
				setIsHovered,
				setPlaybackRate,
				playPause,
				play : () => { wavesurferRef.current.play(); },
				pause : () => { wavesurferRef.current.pause(); },
				setTime: (time) => { wavesurferRef.current.setTime(time) },
				getTime: () => { return wavesurferRef.current.getCurrentTime() },
				skip: (time) => {wavesurferRef.current.skip(time) },
			}
		});

		useEffect(() => { // initialize
			setStatus(_status);

			wavesurferRef.current = WaveSurfer.create({	
				container: innerRef.current,
				height: 0,
				fillParent: true,
				progressColor: 'white',
				cursorColor: 'yellow',
				cursorWidth: 2,
				sampleRate: 16000,
			});
			wavesurferRef.current.registerPlugin(
				SpectrogramPlugin.create({
					colorMap: 'gray',
					scale: "linear",
					fftSamples: (id==-1) ? 512 : 32, // <<< (SPECTROGRAM QUALITY)  zoomed : unzoomed
					labels: (id==-1),
					height: (id==-1) ? 256 : 128, 
				}),
			)

			wavesurferRef.current.load(url).catch((e) => {
				if (e.name === "AbortError" && isDestroyed) {
					console.log("WaveSurfer load aborted cleanly");
				} else {
					console.error("WaveSurfer load failed:", e);
				}
			});

			wavesurferRef.current.on('ready', function() {
				document.getElementById(`loading-spinner-${id}`).style.display = 'none';

				if (linkedSpectro) {
					wavesurferRef.current.setTime(linkedSpectro.getTime());
					wavesurferRef.current.on("timeupdate", (progress) => {
						linkedSpectro.setTime(progress);
					});
				}
				setIsLoaded(true);
			});
			
			return () => { 
				isDestroyed = true;
				wavesurferRef.current.unAll();
				try {
					wavesurferRef.current?.destroy();
				} catch (e) {
					if (e instanceof DOMException && e.name === "AbortError") {
						console.warn("WaveSurfer load aborted cleanly");
					} else {
						console.error("WaveSurfer destroy failed:", e);
					}
				}
			};
		}, [url]);
	
		return (
			<div 
				key={id} 
				className={`
					${(id==-1) ? styles.waveContainerModal : styles.waveContainer} 
					${isLoaded && (
						(status==SpectroStatus.Valid && styles.greenOutline) || 
						(status==SpectroStatus.Invalid && styles.redOutline)
					)}
					${isLoaded && (isSelected ? styles.selectOutline : styles.unselectOutline)}
				`}
				ref={containerRef}
				onMouseEnter={onMouseEnter}
				onMouseLeave={onMouseLeave}
				onClick={onClick}
				style={{ position: "relative" }}
			> 
				{id!=-1 && (<div className={styles.indexOverlay}>{fullIndex+1}</div>)} 
				{id!=-1 && (<div className={styles.filePathOverlay}>{filePath}</div>)} 
				<div id={`loading-spinner-${id}`} className={styles.waveLoadingCircle}></div>
				<div 
					id={`waveform-${id}`} 
					ref={innerRef}
					style={{ width: "100%", height: "256px"}} // the height doesnt matter, it's predetermined by FFT
					onContextMenu={(e) => { e.preventDefault(); if (isSelected) playPause(); }}
				></div>
			</div>	
		)
	}), []);
	
	const ModalSpectrogram = useCallback(forwardRef<SpectroRef, SpectroProps&{toggleModal:()=>void}>(({
		id, // -1 if modal 
		fullIndex=-1,
		url, 
		onMouseEnter, 
		onMouseLeave,
		onClick,
		linkedSpectro=spectrograms.current[selected[0]],
		toggleModal,
	}, ref) => {
		const modalRef = useRef(null);
		return (
			<div ref={modalRef} className={styles.modal}>
				<div style={{ display: 'inline-block', width: 'auto' }} className={styles.indexOverlay}> {linkedSpectro.fullIndex+1} </div>
				<p style={{ display: 'inline', padding: 0, margin: 0 }}>{linkedSpectro.filePath}</p>

				<Spectrogram 
					id={-1} 
					fullIndex={fullIndex}
					url={url} 
					status={linkedSpectro.status}
					onMouseEnter={onMouseEnter}
					onMouseLeave={onMouseLeave}
					onClick={onClick}
					linkedSpectro={linkedSpectro}
					ref={ref}
				/>
				<button onClick={(e)=>{
					toggleModal();
					e.stopPropagation();
				}}>Close</button>
			</div>
		);
	}), [selected]);


	// MODAL

	const [showModal, setShowModal] = useState(false);
	const toggleModal = useCallback(() => {  // wraps setShowModal
		if (selected != null) {
			setShowModal((prev) => {
				setFrozen(!prev);
				if (prev) { // EXIT MODAL
					playingSpectro.current = null;
					return false;
				} else { // SHOW MODAL
					setMouseControl(false);
					if (playingSpectro.current != null) {
						spectrograms.current[playingSpectro.current].pause();
					}
					return true;
				}
			});
		}		
	}, [selected, frozen]);

	useEffect(() => {
		if (showModal) {
			document.getElementById("container").classList.add(styles.noInteraction);
		} else {
			document.getElementById("container").classList.remove(styles.noInteraction);
		}
	}, [showModal]);


	// MENU

	const nextPage = useCallback(() => {
		console.log(currentPage, totalPages);
		if (currentPage < totalPages) {
			setCurrentPage((prev) => Math.min(prev + 1, totalPages));
			setForceReloadKey((prev) => prev + 1);
		}
	}, [currentPage, totalPages]);
	const prevPage = useCallback(() => {
		console.log(currentPage, totalPages);
		if (currentPage > 1) {
			setCurrentPage((prev) => Math.max(prev - 1, 1));
			setForceReloadKey((prev) => prev + 1);
		}
	}, [currentPage, totalPages]);

	const saveToJSON = async () => {
		var obj : SaveData = { page: currentPage, columns: COLS, spectrograms: [] };
		for (let i = 0; i < audioFiles.length; i++) {
			const save = audioFiles[i];
			obj.spectrograms.push({filePath: save.filePath, status: save.status});
		}
		var json = JSON.stringify(obj);

		const filePath = await window.ipc.invoke('save-dialog', null);
		if (filePath) {
			await window.ipc.send("save-file", {filename: filePath, content: json});
		}
	}

	// ACTIONS

	const moveSelectionUp = () => 		{ setMouseControl(false); updateSelected([selected.length==0 ? 0 : Math.max(lastSelected() - COLS, lastSelected() % COLS)]); }
	const moveSelectionDown = () => 	{ setMouseControl(false); updateSelected([selected.length==0 ? 0 : Math.min(lastSelected() + COLS, numFiles-1, numSpots-COLS+(lastSelected() % COLS))]); }
	const moveSelectionLeft = () => 	{ setMouseControl(false); updateSelected([selected.length==0 ? 0 : Math.max(lastSelected() - 1, 0)]); }
	const moveSelectionRight = () => 	{ setMouseControl(false); updateSelected([selected.length==0 ? 0 : Math.min(lastSelected() + 1, numFiles-1)]); }
	const setSpectroStatus = (status) => { 
		for (let i = 0; i < selected.length; i++) {
			updateAudioFile(spectrograms.current[selected[i]].fullIndex, status)
			spectrograms.current[selected[i]].setStatus(status);
		}
		if (showModal) {spectrograms.current[-1].setStatus(status);}
	}
	const playPauseSelection = () => { 
		if (selected.length == 0) { return }; // null
		if (playingSpectro.current != null && playingSpectro.current != selected[0]) { spectrograms.current[playingSpectro.current].pause(); }; // pause existing
		const id = showModal ? -1 : selected[0];

		spectrograms.current[id].setPlaybackRate(playSpeed); // set speed of selected
		const isPlaying = spectrograms.current[id].playPause(); // play/pause selected
		playingSpectro.current = (isPlaying ? selected : null);
	}
	const skipBack = () => { if (selected.length != 0) {spectrograms.current[showModal ? -1 : selected[0]].skip(-skipInterval);}; }
	const skipForward = () => { if (selected.length != 0) {spectrograms.current[showModal ? -1 : selected[0]].skip(skipInterval);}; } 
	const doubleSkipInterval = () => { setSkipInterval((prev) => Math.min(prev*2, MAX_SKIPINTERVAL)) } 
	const halveSkipInterval = () => { setSkipInterval((prev) => Math.max(prev/2, MIN_SKIPINTERVAL)) } 
	const doublePlaySpeed = () => { 
		setPlaySpeed((prev) => {
			let p = Math.min(MAX_PLAYSPEED, prev*2); 
			if (playingSpectro.current != null) {spectrograms.current[playingSpectro.current].setPlaybackRate(p)}; 
			return p;
		}); 
	}
	const halvePlaySpeed = () => { 
		setPlaySpeed((prev) => {
			let p = Math.max(MIN_PLAYSPEED, prev/2); 
			if (playingSpectro.current != null) {spectrograms.current[playingSpectro.current].setPlaybackRate(p)}; 
			return p;
		}); 
	}
	const resetIncrements = () => { 
		setSkipInterval(DEFAULT_SKIPINTERVAL); 
		setPlaySpeed(DEFAULT_PLAYSPEED); 
		if (playingSpectro.current != null) {spectrograms.current[playingSpectro.current].setPlaybackRate(DEFAULT_PLAYSPEED)}; 
	}
	const moreColumns = () => { setCOLS((prev) => { updateSelected([]); return Math.min(prev+1, MAX_COLUMNS); }); }
	const lessColumns = () => { setCOLS((prev) => { updateSelected([]); return Math.max(prev-1, MIN_COLUMNS); }); }

	const keybinds = useMemo(() => ({
		"w": moveSelectionUp,
		"a": moveSelectionLeft,
		"s": moveSelectionDown,
		"d": moveSelectionRight,
		"ArrowUp": moveSelectionUp,
		"ArrowLeft": moveSelectionLeft,
		"ArrowDown": moveSelectionDown,
		"ArrowRight": moveSelectionRight,
		"Tab": moveSelectionRight,
		"z": () => {setSpectroStatus(SpectroStatus.Unverified)},
		"x": () => {setSpectroStatus(SpectroStatus.Valid)},
		"c": () => {setSpectroStatus(SpectroStatus.Invalid)},
		" ": playPauseSelection,
		",": skipBack,
		".": skipForward,
		"l": doubleSkipInterval,
		"k": halveSkipInterval,
		"m": doublePlaySpeed,
		"n": halvePlaySpeed,
		";": lessColumns,
		"'": moreColumns,
		"r": resetIncrements,
		"o": toggleModal,
		"Enter": nextPage,
		"Backspace": prevPage,
	}), [
		moveSelectionUp, moveSelectionLeft, moveSelectionDown, moveSelectionRight,
  		setSpectroStatus, playPauseSelection, skipBack, skipForward,
  		doubleSkipInterval, halveSkipInterval, doublePlaySpeed, halvePlaySpeed,
  		lessColumns, moreColumns, resetIncrements, toggleModal,
  		nextPage, prevPage
	]);

	useEffect(() => { // handle keyboard input
		const handleKeyDown = (event) => {
			if (event.key == " " || event.key.includes("Arrow") || event.key == "Tab") {
				event.preventDefault(); 
			}

			const func = keybinds[event.key];				
			if (func) {
				func();
			}
		};

		window.addEventListener("keydown", handleKeyDown);
		return () => window.removeEventListener("keydown", handleKeyDown);
	}, [selected, playingSpectro, playSpeed, skipInterval, frozen]);
	

	const [isSelecting, setIsSelecting] = useState(false);
	const [rectStart, setRectStart] = useState(null);
	const [rect, setRect] = useState(null);
	const containerRef = useRef(null)

	// BOX SELECT

	const handleMouseDown = (e, canSelect=true) => {
		const x = e.clientX;
		const y = e.clientY;
		setRectStart({ x, y });
		setRect({ x, y, width: 0, height: 0 });
		setIsSelecting(canSelect);
	};

	const handleMouseMove = (e) => {
		if (!isSelecting) return;

		const x = e.clientX;
		const y = e.clientY;

		const newRect = {
			x: Math.min(rectStart.x, x),
			y: Math.min(rectStart.y, y),
			width: Math.abs(x - rectStart.x),
			height: Math.abs(y - rectStart.y),
		};

		setRect(newRect);
	};

	const handleMouseUp = () => {
	if (!rect) return;
		let selection = [];

		spectrograms.current.forEach((spectrogram) => {
			const el = spectrogram.containerRef.current;
			if (!el) {
				return;
			}
			const box = el.getBoundingClientRect();

			const relative = {
				left: box.left,
				top: box.top,
				right: box.right,
				bottom: box.bottom,
			};

			const overlap = (
				rect.x < relative.right &&
				rect.x + rect.width > relative.left &&
				rect.y < relative.bottom &&
				rect.y + rect.height > relative.top
			);

			if (overlap) selection.push(spectrogram.id);
		});

		updateSelected(selection)
		setIsSelecting(false);
		setRect(null);
	};

	// <input type="file" accept=".mp4, .wav, .txt, .json" className={styles.hiddenInputFile} multiple onChange={handleFileSelection}/>
	return (
		<React.Fragment>
			<Head>
				<title>Verify Page</title>
			</Head>
			<div 
				id="container" 
				className={styles.container} 
				ref={containerRef}
				onClick={() => {/*if (!frozen) updateSelected([])*/}}
				onMouseMove={(e) => {if (!frozen) {setMouseControl(true); handleMouseMove(e)}}}
				onMouseDown={(e) => {if (!frozen) {setMouseControl(true); e.preventDefault(); handleMouseDown(e)}}}
				onMouseUp={(e) => {if (!frozen) {setMouseControl(true); handleMouseUp()}}}
				style={{ userSelect: 'none' }}
			>
				<div 
					className = {styles.verifyButtonMenu}
					onMouseDown={(e) => {if (!frozen) {e.stopPropagation(); setMouseControl(true); handleMouseDown(e, false)}}}
				>

					<label className={styles.pickFiles} onClick={(e) => {
						e.stopPropagation()
						handleFileSelection()
					}}>
						<p>Select files</p>
					</label> 
					{audioFiles.length > 0 && (
						<>
							<div className={styles.smallContainer}>
								<p style={{ margin: '5px 0px' }}>Save</p>

								<div className={styles.save} onClick={(e) => {
									e.stopPropagation()
									saveToJSON()
								}}>
									<Image
									src="/images/database.png"
									alt="Save to JSON"
									width={30}
									height={30}
									/>
								</div>
							</div>

							<div className={styles.smallContainer}>
								<p>
									Page:{" "}
									<input
										type="number"
										value={currentPage}
										min={1}
										max={totalPages}
										onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
											const value = parseInt(e.target.value);
											if (!isNaN(value) && value >= 1 && value <= totalPages) {
												setCurrentPage(value);
											}
										}}
										style={{ width: "3em", textAlign: "center" }}
									/>{" "}
									/ {totalPages}
								</p>

								<div 
								style={{ overflow: 'hidden', display: 'flex', alignItems: 'center' }} 
								className={styles.smallContainerRow}
								>
									<div className={currentPage>1 ? styles.prevFiles : styles.disabled} onClick={prevPage}>
										<Image
										src="/images/LArrow.png"
										alt="Previous files"
										width={20}
										height={20}
										style={{ display: 'block' }}
										/>
									</div>	
									<div className={currentPage<totalPages ? styles.nextFiles : styles.disabled} onClick={nextPage}>
										<Image
										src="/images/RArrow.png"
										alt="Next files"
										width={20}
										height={20}
										style={{ display: 'block' }}
										/>
									</div>
								</div>
							</div>
						</>
					)}
					
					<div className={styles.smallContainer}>
						<p>Skip Interval: {skipInterval}</p>
						<div className={styles.smallContainerRow}>
							<button onClick={(e) => {halveSkipInterval(); e.stopPropagation()}}>-</button>
							<button onClick={(e) => {doubleSkipInterval(); e.stopPropagation()}}>+</button>
						</div>
					</div>
					
					<div className={styles.smallContainer}>
						<p>Playback Speed: {playSpeed}</p>
						<div className={styles.smallContainerRow}>
							<button onClick={(e) => {halvePlaySpeed(); e.stopPropagation()}}>-</button>
							<button onClick={(e) => {doublePlaySpeed(); e.stopPropagation()}}>+</button>
						</div>
					</div>

					<div className={styles.smallContainer}>
						<p>COLUMNS: {COLS}</p>
						<div className={styles.smallContainerRow}>
							<button onClick={(e) => {lessColumns(); e.stopPropagation()}}>-</button>
							<button onClick={(e) => {moreColumns(); e.stopPropagation()}}>+</button>
						</div>
					</div>

					<div>
						<p>Selected: 
							{	
								" " + (
									selected.length==0 ? "none" : 
									selected.length==1 ? spectrograms.current[selected[0]]?.fullIndex+1 :
									(firstSelected()+1) + "-" + (lastSelected()+1)
								)
							}
						</p>
					</div>
				</div>

				{audioFiles.length > 0 && (
					<>
						<div id="grid" key={forceReloadKey} className={styles.grid} style={{
							gridTemplateColumns: `repeat(${COLS}, 1fr)`,
							gridTemplateRows: `repeat(${ROWS}, auto)`,
						}}>
							{currentFiles.map(({index, filePath, url, status}, i) => {
								return (
									<Spectrogram 
										key={i}
										id={i} 
										fullIndex={index}
										url={url} 
										filePath={filePath}
										status={status}
										onMouseEnter={() => {
											if (mouseControl) {
												updateHovered(i);
											}
										}}
										onMouseLeave={() => {
											if (mouseControl) {
												updateHovered(null);
											}
										}}
										onClick={(e) => {
											e.stopPropagation();
										}}
										linkedSpectro={null}
										ref={(el) => {
											if (el) spectrograms.current[i] = el; // Populate dynamically
										}}
									/>
								)
							})}
						</div>
					</>
				)}

				<>
					{showModal && 	
						createPortal(
							<ModalSpectrogram
								key={-1}
								id={-1} 
								fullIndex={-1}
								url={spectrograms.current[firstSelected()].url} 
								status={spectrograms.current[firstSelected()].status} 
								onMouseEnter={()=>{}}
								onMouseLeave={()=>{}}
								onClick={(e)=>{e.stopPropagation()}}
								linkedSpectro={spectrograms.current[firstSelected()]}
								ref={(el) => {
									if (el) spectrograms.current[-1] = el; // Populate dynamically
								}}
								toggleModal={toggleModal}
							/>,
							document.body
						)
					}
				</>

				{isSelecting && rect && (
					<div
						style={{
							position: "absolute",
							left: rect.x,
							top: rect.y,
							width: rect.width,
							height: rect.height,
							backgroundColor: "rgba(0, 120, 215, 0.2)",
							border: "1px solid #0078d7",
							pointerEvents: "none",
							zIndex: 10,
						}}
					/>
				)}
			</div>
		</React.Fragment>
	)
}